# :triangular_flag_on_post: 프로그래밍

| 목차 | 내용 |
| --- | --- |
| :one: | [객체지향](#pencil2-객체지향) |
| :two: | [소프트웨어 프로세스 모델](#pencil2-소프트웨어-프로세스-모델) |
| :three: | [소프트웨어 아키텍처 정의](#pencil2-소프트웨어-아키텍처-정의) |
| `기출` | [Q1. JAVA와 C의 차이를 설명하시오.](#heavy_check_mark-q1-소프트웨어-위기에-대해서-설명하시오)<br/>[Q2. JVM 가비지 컬렉션 동작 과정을 설명하시오.](#heavy_check_mark-q2-소프트웨어-공학이-필요한-이유는-무엇인지-설명하시오)<br/>[Q3. JAVA에 적용된 OOP에 대해서 설명하시오.](#heavy_check_mark-q3-소프트웨어-개발-경험과-소프트웨어-개발-시-적용한-개발-방법론이-있다면-설명하시오)<br/>[Q4. 형상관리 활용 경험을 설명하시오.(C+Z/Y)](#heavy_check_mark-q4-소프트웨어-프로젝트-진행-경험에-대해서-설명하시오) |

<br/>


### :pencil2: 객체지향
* 소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것
* 소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의
* 필드는 객체 내부에 `선언된 변수`를 의미하고, 메서드는 객체 내부에 `정의된 동작`을 의미<br/>
*
  | 절차지향 | 객체지향 |
  | ------ | ------ |
  | * 일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열<br/>* 데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점 | * 현실 세계를 객체 단위로 프로그래밍하며, 객체는 필드(*데이터*)와 메서드(*코드*)를 하나로 묶어 표현<br/>* 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용<br/>* 소프트웨어 개발과 보수를 간편하게 하며, 직관적인 코드 분석이 가능 |

* 객체지향 주요 개념<br/>
  | 개념 | 내용 |
  | --- | --- |
  | 캡슐화(정보은닉) | 필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것 |
  | 상속 | 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것 |
  | 다형성 | 대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현<br/>실행 도중 동일한 이름의 다양한 구현체 중에서 메서드 선택 가능 |

<br/><br/>

### :pencil2: 객체지향 프로그래밍 언어: JAVA
:arrow_forward: 자바의 목적
* Write Once Run Anywhere
* 독립적 플랫폼
* 작성된 코드는 수정이 없이, 재컴파일 없이 실행 가능

<br/>

:arrow_forward: Java 언어의 개발 목적
* 프로그램 개발을 쉽게 함
* interpreted 환경
* 다중 thread 사용
* 동적으로 프로그램 변화
* 코드 자체적으로 security 보장

<br/>

:arrow_forward: JVM(Java Virtual Machine)
* JVM은 시스템/OS마다 다름
* Java Application에서는 JDK 안에서 실행
* Applet의 경우에는 browser 안에 JVM(*.jar*)이 있어 Java 코드 실행
* Java compiler는 소스코드를 JVM에 대한 machine code instruction으로 변환하면 JVM으로 구현된 development tool에 의해 interpreted 됨

<br/>

:arrow_forward: Garbage Collection
* Java가 알아서 메모리 최적화(release)
* Java Program의 life cycle동안 자동적으로 동작해 de-allocate 메모리에 필요와 부족을 제거

<br/>

  ![image](https://user-images.githubusercontent.com/42609725/175384891-e5fcb913-3875-4c71-952a-5a5aa8db9375.png)

<br/>

:arrow_forward: Process
* 프로그램: 저장장치에 저장되어 있는 정적인 상태
* 프로세서: 실행을 위해 메모리에 올라온 동적인 상태
* 프로그램이 프로세스가 됨: OS로부터 프로세스 제어 블록을 얻는다는 뜻
* 프로세스 종료: 해당 프로세스 제어 블록 폐기

<br/>

:arrow_forward: Thread
* 프로세스에서 실행 제어만 분리한 실행 단위
* 프로세서를 사용하는 기본 단위, 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름
* 같은 그룹의 스레드는 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유

<br/>

![image](https://user-images.githubusercontent.com/42609725/175385899-c5519c1f-65bd-406f-bf40-6d0b5be8f2a2.png)

<br/>

|||
|---|---|
| 멀티 태스킹 | 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분 |
| 멀티 프로세싱 | CPU를 여러 개 사용하여 여러 개의 Thread를 동시에 처리하는 작업 환경 |
| CPU 멀티 Thread | 하드웨어적인 방법으로 하나의 CPU에서 여러 Thread를 동시에 처리하는 병렬 처리 기법 |
| 멀티 Thread | OS가 소프트웨어적으로 프로세스를 작은 단위의 Thread로 분할하여 운영 |

<br/>

:arrow_forward: 병행성(concurrency) 문제
* 두 개 이상의 Thread가 어떤 객체에 있는 하나의 데이터에 접근하게 되는 경우
* 서로 다른 두 스택에서 실행되는 메소드가 객체에 있는 동일한 객체에 대한 getter/setter메소드를 호출하게 되는 경우
* Thread는 자신의 interpret 상태를 기억하지 못함

<br/>

:arrow_forward: Thread에서의 동기화
* 멀티 Thread환경에서 한번에 하나의 Thread만이 공유 데이터를 접근할 수 있도록 제어하는 것
* 다중 쓰레드에서 데이터를 공유하기 위해서는 해당 쓰레드의 상태와 행동 등을 고려

<br/><br/>

### :pencil2: 형상관리

:arrow_forward: 정의
* SW 개발 및 유지보수 과정에서 발생하는 변경 사항들을 관리하기 위해 개발된 일련의 활동
* SW 개발의 전 단계에 적용되는 활동으로, 유지보수 단계에서 수행

<br/>

:arrow_forward: 목적
* 개발비용 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증함
* 주요 기능: 버전관리, 리비전관리, 소스관리, 소스코드관리

<br/>

:arrow_forward: 종류
* SVN, Git, Mercurial, Bazaar 등
  | SVN | Git |
  | --- | --- |
  | 중앙 집중 모델<br/>소규모 시스템 적합<br/>간단한 기능과 조작법<br/>브랜치 merge작업의 부담이 큼<br/>저장소 서버의 지속적 관리 필요<br/>안정된 네트워크 환경 | 분산 개발 모델<br/>대규모 시스템 적합<br/>높은 오픈 소스 활용도와 다양한 기능<br/>commit할 때 메세지의 강제성<br/>사설저장소 이용에 대한 비용 발생<br/>선행학습 필요 |

<br/>

:arrow_forward: 빌드도구
* 소스코드를 컴파일, 테스트, 정적 분석 등을 실시해 실행 가능한 애펄리케이션으로 자동 생성하는 프로그램
* 프로젝트를 진행함에 따라 라이브러리 버전을 자동으로 동기화
  | 종류 | 내용 |
  | --- | --- |
  | ANT | XML기반 빌드 스크립트 개발<br/>명확한 빌드 절차 정의 필요 |
  | MAVEN | 프로젝트에 필요한 모든 종속성(Dependency)를 리스트의 형태로 관리<br/>전자정부프레임워크 |
  | Gradle | ANT와 MAVEN의 단점을 보완한 오픈소스 기반의 Build 자동화 도구<br/>안드로이드 스튜디오 |
<br/><br/>


-----
<br/>

### :heavy_check_mark: Q1. JAVA와 C의 차이를 설명하시오.

  > #### :star: 절차지향 vs 객체지향, HW 최적화 vs HW 독립적 등 여러 관점에서 비교 설명
  > <br/>
  >
  > C언어는 아두이노를 활용한 IoT 수업에 사용했고, 자바는 안드로이드 어플 제작 시 사용했습니다.<br/>
  > **하드웨어를 제어할 때 C언어가 적합한 언어**라고 생각합니다. 자바를 사용할 때에는 다양한 유형의 데이터를 정의와 데이터 간의 관계 설정, 사용자의 동작을 정의, 구현하는 과정을 거쳤는데, 실제 업무와 유사하여 **규모 있는 프로젝트를 개발할 때 자바가 적합했던 언어**였습니다. 또한 개발 환경에 있어서도 윈도우 환경에서 개발한 프로그램을 그대로 리눅스 기반으로 알고 있는 안드로이드 환경에서 동작하는 것을 통해서 하드웨어 독립적으로 운영이 가능한 것이 C언어와의 차이라고 할 수 있습니다.

<br/><br/>

### :heavy_check_mark: Q2. JVM 가비지 컬렉션 동작 과정을 설명하시오.

  > #### :star: 가비지 컬렉션은 메모리와 연관되어 있으므로 SW 개발 경험 중 메모리 부족 현상을 겪은 경험이 있다면 그를 토대로 설명
  > <br/>
  >
  > **가비지 컬렉션은 JVM에서 메모리 관리를 하는 방법으로 더 이상 사용하지 않는 메모리에 대해 수집해 스스로 동작해서 사용을 헤제하는 기능**<br/>
  > C언어를 사용할 때에는 코드에서 메모리의 할당과 함께 해제를 같이 처리해주었는데, 자바에서는 사용하지 않는 메모리에 대해서는 메모리의 참조변수에 null을 대입해 참조변수와 연결된 메모리가 더 이상 사용하지 않음을 JVM에 알려주는 것만으로 메모리 해제 요청을 하였습니다.

<br/><br/>

### :heavy_check_mark: Q3. JAVA에 적용된 OOP에 대해서 설명하시오.

  > #### :star: 실제 작업한 사례를 통해 설계한 객체와 클래스를 비교해서 설명
  > <br/>
  >
  > [관광정보 제공 서비스 프로젝트 개발]
  > * 서비스에서 제공되는 주요 정보인 관광지 / 식당 / 호텔 등을 객체로 정의
  > * 클래스에서는 관광지의 이름은 String타입으로 정의, 관광지의 위도 경도는 double타입으로 정의
  > * 길을 탐색하는 기능은 메소드로 구현
  > 객체는 실세계를 모델링 한 것이면 클래스는 모델링 한 것을 실제 코드로 구현한 것입니다.

<br/><br/>

### :heavy_check_mark: Q4. 형상관리 활용 경험을 설명하시오.(C+Z/Y)

  > #### :star: 형상관리의 경험이 있다면 해당 경험을 얘기하고, 없다면 회사에서 제공하는 서비스나 SW 대상으로 필요성을 설명
  > <br/>
  >
  > 동시에 같이 개발하면서 서로의 코드를 참조하고, 확인을 위해 SVN 이용해 형상관리를 진행했다.
  > SVN을 활용한 형상관리를 하면서 코드 작업 후 업데이트할 때 오류가 있는 코드를 업데이트 하고나, 업데이트 시 정확한 코멘트를 남기지 않아 애를 먹은 경험도 있다. 초반에는 혼란을 겪었지만, 수시로 베이스라인 변경과 통제를 통해 형상관리 프로젝트를 체계적으로 관리할 수 있었습니다.

<br/>


